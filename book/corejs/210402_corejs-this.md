# 코어 자바스크립트 Part 3. this

# this

- 다른 객체지향 언어에서 `this`는 클래스로 생성한 인스턴스 객체를 의미하지만, 자바스크립트에서의 `this`는 상당히 자유롭다.

- `this`를 어디에서 사용하느냐에 따라서 `this`가 가리키는 대상이 달라진다.
- **함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 `this`는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.**

# 명시적 this 바인딩이 없는 한 늘 성립하는 규칙

- 전역 공간에서의 `this`는 **전역 객체**를 가리킨다. (브라우저에서는 `window`, Node.js에서는 `global`)
- 어떤 함수를 **메서드**로서 호출한 경우 `this`는 호출 주체(메서드명 앞의 객체)를 가리킨다. 즉, 함수 앞에 명시되어 있는 객체가 곧 `this`가 되는 것.
- 어떤 함수를 **함수**로서 호출한 경우 `this`는 전역 객체를 참조한다. 이는 메서드의 내부 함수에서도 같다.) 함수는 전역 객체의 메서드다! 라고 생각하면 이해하기 쉽다.

  - cf. 함수로서 호출과 메서드로서 호출의 차이는 독립성에 있다. 함수는 그 자체로 독립적인 기능을 수행하지만, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.

    - 흔히 메서드를 '객체의 프로퍼티에 할당된 함수'라고 이해하곤 하는데 이는 반은 맞고 반은 틀리다. 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로 메서드가 되는 것이 아니라 **객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않은 경우에는 함수로 동작한다.**

    - 함수로서 호출과 메서드로서의 호출은 함수 앞에 점(.)이 있는지를 보거나 함수를 호출할 때 앞에 객체가 명시되어 있는지를 보면 쉽게 확인할 수 있다.

- cf. ES6에서는 함수 내부에서 `this`가 전역 객체를 참조하는 문제를 보완하고자 `this`를 바인딩하지 않는 `화살표 함수` 함수를 도입했다. 화살표 함수는 실행 컨텍스트가 생성될 때 `thisBinding` 과정이 빠지게 되어서, 상위 스코프의 `this`를 그대로 활용할 수 있다. (화살표 함수가 선언되어 있는 실행 컨텍스트의 `thisBinding` 정보를 참조하는 것. 즉, 스코프 체인을 통해 `this` 참조가 이루어지는 것이다)

- 콜백 함수는 기본적으로는 함수의 `this`와 같다. 제어권을 가진 함수가 callback의 `this`를 명시한 경우 그에 따른다.
- 생성자 함수에서의 `this`는 새로 생성될 인스턴스를 참조한다.

# 명시적 this 바인딩

- `call`, `apply` 메서드는 `this`를 명시적으로 지정하면서 함수 또는 메서드를 호출한다.
- `bind` 메서드는 `this` 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만든다.
- 요소를 순회하면서 콜백 함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 `this`를 받기도 한다.
- `call`, `apply`는 즉시 호출하고 `bind`는 새로운 함수를 생성한다.

# 정리

- 전역공간에서 `window/global`
- 함수 호출시 `window/global`
- 메서드 호출시 `메서드 호출 주체 (메서드 명 앞)`
- callback 호출시 `기본적으로는 함수 내부에서와 동일`
- 생성자 함수 호출시 `인스턴스`
